<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>進階教室座位隨機分配系統（含匯出與精細規則）</title>
<style>
    body { font-family: Arial, sans-serif; padding: 20px; background: #eef2f3; }
    h1 { text-align: center; margin-bottom: 12px; }
    #panel { max-width: 920px; margin: auto; background: white; padding: 18px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.06); }
    textarea, input, select { width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #ccc; font-size: 15px; margin-bottom: 10px; box-sizing: border-box; }
    .row { display:flex; gap:10px; }
    .row > div { flex:1 }
    .controls { display:flex; flex-wrap:wrap; gap:8px; }
    button { padding: 10px 14px; font-size: 15px; cursor:pointer; border-radius:8px; border:none; background:#4CAF50; color:white }
    #seat-grid { display:grid; gap:12px; max-width:1000px; margin:20px auto; transition:0.25s; }
    .seat { background:white; border-radius:10px; padding:14px; text-align:center; box-shadow:0 3px 8px rgba(0,0,0,0.06); font-size:16px; transition:transform .25s, box-shadow .25s; }
    .seat.animate { animation: pop .35s ease; }
    @keyframes pop { 0%{transform:scale(1)}50%{transform:scale(1.08)}100%{transform:scale(1)} }
    .seat-number { font-weight:700; margin-bottom:6px }
    #stage { text-align:center; margin:12px; font-size:18px; font-weight:700 }
    .small { font-size:13px; color:#666 }
    @media(max-width:720px){ .row{flex-direction:column} .controls{flex-direction:column} }
</style>
</head>
<body>
<h1>進階教室座位隨機分配系統（含匯出與精細規則）</h1>
<div id="panel">
  <label>學生名單（每行一個）</label>
  <textarea id="names" rows="6" placeholder="學生 1
學生 2
學生 3 ...">學生 1
學生 2
學生 3
學生 4
學生 5
學生 6
學生 7
學生 8
學生 9
學生 10
學生 11
學生 12
學生 13
學生 14
學生 15
學生 16
學生 17
學生 18
學生 19
學生 20</textarea>

  <div class="row">
    <div>
      <label>座位列數（rows）</label>
      <input id="rows" type="number" min="1" value="4">
    </div>
    <div>
      <label>座位行數（cols）</label>
      <input id="cols" type="number" min="1" value="5">
    </div>
  </div>

  <label>禁止一起就座（多組以分號或換行分隔；每組用逗號分開成 pair，例如：學生1,學生5 ; 學生2,學生3）</label>
  <textarea id="banTogether" rows="2" placeholder="學生 1,學生 5"></textarea>
  <div class="row small">
    <div>
      <label>禁止邏輯（禁止一起 =）</label>
      <select id="banMode">
        <option value="adjacent">不得相鄰（左右上下）</option>
        <option value="sameRow">不得同一列（row）</option>
        <option value="anywhere">不得同一張座位表（完全禁止同時出現）</option>
      </select>
    </div>
    <div>
      <label>相鄰定義（adjacent）</label>
      <select id="adjacentMode">
        <option value="4">左右上下（4-鄰居）</option>
        <option value="2">左右（水平相鄰）</option>
      </select>
    </div>
  </div>

  <label>必須一起就座（多組以分號分隔；每組內用逗號分開，例如：學生2,學生6 ; 學生7,學生8,學生9）</label>
  <textarea id="mustTogether" rows="2" placeholder="學生 2,學生 6"></textarea>
  <div class="row small">
    <div>
      <label>必須一起邏輯（必須一起 =）</label>
      <select id="mustMode">
        <option value="adjacent">必須相鄰（形成連通群）</option>
        <option value="sameRow">必須同一列（row）</option>
      </select>
    </div>
    <div>
      <label>匯入 Excel (.xlsx)</label>
      <input id="excel" type="file" accept=".xlsx" />
    </div>
  </div>

  <div class="controls" style="margin-top:6px">
    <button id="btnCreate">建立座位</button>
    <button id="btnRandom">隨機分配（含抽籤動畫）</button>
    <button id="btnReshuffle">重抽（快速動畫）</button>
    <button id="btnExportPDF">匯出 PDF</button>
    <button id="btnExportImg">匯出圖檔（PNG）</button>
  </div>
  <div style="margin-top:8px" class="small">建議：先按「建立座位」，再貼名單，然後按「隨機分配」。</div>
</div>

<div id="stage">講台</div>
<div id="seat-grid"></div>

<!-- dependencies -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<script>
(() => {
  // encapsulated scope
  let totalSeats = 20;

  function getPeople() {
    const raw = document.getElementById('names').value.trim();
    return raw ? raw.split(/
+/).map(x => x.trim()).filter(Boolean) : [];
  }

  function generateSeats() {
    const rows = parseInt(document.getElementById('rows').value) || 1;
    const cols = parseInt(document.getElementById('cols').value) || 1;
    totalSeats = rows * cols;

    const grid = document.getElementById('seat-grid');
    grid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
    grid.innerHTML = '';

    for (let i = 1; i <= totalSeats; i++) {
      const div = document.createElement('div');
      div.className = 'seat';
      div.dataset.index = i-1; // 0-based
      div.innerHTML = ` <div class='seat-number'>座位 ${i}</div> <div id='seat-${i}' class='assigned'>(空)</div>`;
      grid.appendChild(div);
    }
  }

  function shuffleArray(arr) {
    const a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  function parseBanPairs(text) {
    if (!text) return [];
    return text.split(/[;
]+/).map(group => group.split(/,|，/).map(s=>s.trim()).filter(Boolean)).filter(arr=>arr.length>=2);
  }

  function parseMustGroups(text) {
    if (!text) return [];
    return text.split(/[;
]+/).map(group => group.split(/,|，/).map(s=>s.trim()).filter(Boolean)).filter(arr=>arr.length>=1);
  }

  function indexToRC(index, cols) {
    return { r: Math.floor(index/cols), c: index % cols };
  }

  function manhattan(i, j, cols) {
    const a = indexToRC(i, cols), b = indexToRC(j, cols);
    return Math.abs(a.r - b.r) + Math.abs(a.c - b.c);
  }

  function areConnected(indices, cols) {
    // indices: array of indices; check if they form a connected component using 4-neighbor adjacency
    if (indices.length <= 1) return true;
    const set = new Set(indices);
    const visited = new Set();
    const stack = [indices[0]];
    visited.add(indices[0]);
    while (stack.length) {
      const cur = stack.pop();
      // neighbors: cur-1, cur+1, cur-cols, cur+cols
      const neighbors = [cur-1, cur+1, cur-cols, cur+cols];
      for (const n of neighbors) {
        if (set.has(n) && !visited.has(n)) {
          visited.add(n); stack.push(n);
        }
      }
    }
    return visited.size === set.size;
  }

  function checkConstraints(arr) {
    // arr is array of assigned names in seat order
    const rows = parseInt(document.getElementById('rows').value) || 1;
    const cols = parseInt(document.getElementById('cols').value) || 1;
    const banPairs = parseBanPairs(document.getElementById('banTogether').value);
    const banMode = document.getElementById('banMode').value;
    const adjacentMode = document.getElementById('adjacentMode').value; // '4' or '2'

    for (const pair of banPairs) {
      // only consider first two names in each pair
      const [a,b] = pair;
      if (!a || !b) continue;
      const posA = arr.indexOf(a);
      const posB = arr.indexOf(b);
      if (posA === -1 || posB === -1) continue; // missing -> ok

      if (banMode === 'anywhere') return false; // if both present anywhere
      if (banMode === 'sameRow') {
        if (Math.floor(posA/cols) === Math.floor(posB/cols)) return false;
      }
      if (banMode === 'adjacent') {
        const dist = manhattan(posA, posB, cols);
        if (adjacentMode === '2') {
          // only horizontal neighbors: same row and abs(c diff)==1
          if (Math.floor(posA/cols) === Math.floor(posB/cols) && Math.abs((posA%cols)-(posB%cols))===1) return false;
        } else {
          if (dist === 1) return false;
        }
      }
    }

    const mustGroups = parseMustGroups(document.getElementById('mustTogether').value);
    const mustMode = document.getElementById('mustMode').value;
    for (const group of mustGroups) {
      const positions = group.map(name => arr.indexOf(name)).filter(p=>p!==-1);
      if (positions.length !== group.length) return false; // some member missing
      if (mustMode === 'sameRow') {
        const row = Math.floor(positions[0]/cols);
        if (!positions.every(p => Math.floor(p/cols) === row)) return false;
      }
      if (mustMode === 'adjacent') {
        // require connected block via 4-neighbor adjacency
        if (!areConnected(positions, cols)) return false;
      }
    }

    return true;
  }

  function assignToSeats(shuffled) {
    for (let i = 1; i <= totalSeats; i++) {
      const seatEl = document.getElementById(`seat-${i}`);
      if (!seatEl) continue;
      seatEl.textContent = shuffled[i-1] || '(空)';
      const parent = seatEl.parentElement;
      parent.classList.add('animate');
      setTimeout(()=>parent.classList.remove('animate'), 420);
    }
  }

  function randomizeSeatsAnimated() {
    const people = getPeople();
    if (people.length < totalSeats) { alert('學生數量少於座位數！'); return; }

    let shuffled; let attempts = 0; const maxAttempts = 5000;
    do { shuffled = shuffleArray(people); attempts++; } while(!checkConstraints(shuffled) && attempts < maxAttempts);
    if (attempts >= maxAttempts) { alert('無法在合理次數內找到符合限制的排列。請放寬條件或檢查名單。'); return; }

    // animated reveal: highlight each seat briefly and then assign final names
    const seats = Array.from(document.querySelectorAll('.seat'));
    let i = 0;
    const interval = setInterval(()=>{
      seats.forEach(s=> s.style.transform='scale(1)');
      if (seats[i]) seats[i].style.transform='scale(1.06)';
      i++;
      if (i > seats.length) { clearInterval(interval); assignToSeats(shuffled); }
    }, 55);
  }

  function reshuffleAnimation() {
    const seats = Array.from(document.querySelectorAll('.seat'));
    seats.forEach((el)=> el.style.transform = `translateY(${Math.random()*8-4}px) rotate(${Math.random()*4-2}deg)`);
    setTimeout(()=>{ seats.forEach(el=> el.style.transform=''); randomizeSeatsAnimated(); }, 300);
  }

  async function exportPDF() {
    const grid = document.getElementById('seat-grid');
    const stage = document.getElementById('stage');
    // create a clone to include stage + grid nicely
    const wrapper = document.createElement('div');
    wrapper.style.background = '#fff';
    wrapper.style.padding = '20px';
    wrapper.style.width = (grid.offsetWidth + 40) + 'px';
    const stageClone = stage.cloneNode(true);
    const gridClone = grid.cloneNode(true);
    gridClone.style.marginTop = '8px';
    wrapper.appendChild(stageClone); wrapper.appendChild(gridClone);

    document.body.appendChild(wrapper);
    try {
      const canvas = await html2canvas(wrapper, { scale: 2 });
      const imgData = canvas.toDataURL('image/png');
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF({ orientation: 'landscape', unit: 'pt', format: [canvas.width, canvas.height] });
      pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
      pdf.save('seating-chart.pdf');
    } catch (err) { console.error(err); alert('匯出 PDF 發生錯誤'); }
    document.body.removeChild(wrapper);
  }

  async function exportImage() {
    const grid = document.getElementById('seat-grid');
    const stage = document.getElementById('stage');
    const wrapper = document.createElement('div');
    wrapper.style.background = '#fff'; wrapper.style.padding = '20px'; wrapper.style.display='inline-block';
    wrapper.appendChild(stage.cloneNode(true)); wrapper.appendChild(grid.cloneNode(true));
    document.body.appendChild(wrapper);
    try {
      const canvas = await html2canvas(wrapper, { scale: 2 });
      const data = canvas.toDataURL('image/png');
      const a = document.createElement('a'); a.href = data; a.download = 'seating-chart.png'; a.click();
    } catch (err) { console.error(err); alert('匯出圖檔發生錯誤'); }
    document.body.removeChild(wrapper);
  }

  function setupExcelImport() {
    const excelInput = document.getElementById('excel');
    if (!excelInput) return;
    excelInput.addEventListener('change', (e)=>{
      const file = e.target.files[0]; if (!file) return;
      const reader = new FileReader();
      reader.onload = function(evt){
        try {
          const data = new Uint8Array(evt.target.result);
          const workbook = XLSX.read(data, { type: 'array' });
          const sheet = workbook.Sheets[workbook.SheetNames[0]];
          const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });
          const names = rows.map(r => r[0]).filter(Boolean);
          document.getElementById('names').value = names.join('
');
        } catch (err) { console.error(err); alert('讀取 Excel 發生錯誤，請確認檔案格式與內容。'); }
      };
      reader.readAsArrayBuffer(file);
    });
  }

  // wire up buttons once DOM is ready
  document.addEventListener('DOMContentLoaded', ()=>{
    document.getElementById('btnCreate').addEventListener('click', generateSeats);
    document.getElementById('btnRandom').addEventListener('click', randomizeSeatsAnimated);
    document.getElementById('btnReshuffle').addEventListener('click', reshuffleAnimation);
    document.getElementById('btnExportPDF').addEventListener('click', exportPDF);
    document.getElementById('btnExportImg').addEventListener('click', exportImage);
    setupExcelImport();
    generateSeats();
  });

  // expose for debugging
  window.__seatRandomizer = { generateSeats, randomizeSeatsAnimated, reshuffleAnimation };
})();
</script>
</body>
</html>
